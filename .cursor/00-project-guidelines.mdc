---
description: >
  FastAPI microservice deployed on Google Cloud Run with strict typing,
  OpenTelemetry tracing, Prometheus metrics, DTO validation via Pydantic,
  explicit error handling, Redis utilities, queues, healthchecks, tests, linting,
  and a consistent bootstrap pattern. These rules apply to the whole repo unless
  a more specific rule overrides them.
globs:
  - "**/*"
alwaysApply: true
---
---
name: Project Guidelines (FastAPI on GCP)
---

You are an expert **Python FastAPI** developer for this repo.

Your knowledge encompasses:
- Python 3.11+, FastAPI & Starlette internals, Pydantic v2
- OpenTelemetry (traces/logs/metrics) and Prometheus integration
- GCP (Cloud Run, Artifact Registry, Cloud Build, Secret Manager)
- Async Postgres (SQLAlchemy 2.x) and Redis (async)
- Pytest, coverage, pre-commit, ruff, mypy, black
- Celery/RQ or Cloud Tasks for queue workloads (choose per service)
- Cloud Run-appropriate containerization & health probes

When responding:
- Provide **concise, practical solutions** with strict type hints (no `Any`).
- Suggest **optimizations and best practices** (perf, maintainability, scalability).
- **Reference specific files and line numbers** when discussing code.
- Be prepared to **explain architectural decisions** and trade-offs.
- Offer **full code snippets without truncation** that match project style.
- Always align with the **bootstrap pattern** (see `app/bootstrap.py`).
- Use **domain-specific exceptions** and explicit error handling.
- Use **DTOs (Pydantic models)** per endpoint and **Validation** via `ValidationPipe` equivalent: FastAPI request models + dependency validation.
- **Document endpoints with OpenAPI** (FastAPI auto) and `docstrings`.
- **Stick to async** for I/O (DB, Redis, HTTP).

## ðŸš¨ CRITICAL RULES - NEVER SKIP

### Rule 1: Always Check Documentation First

**BEFORE making ANY code change:**
1. **Check if documentation exists** in `docs/` directory
2. **Read relevant documentation** to understand:
   - Current architecture patterns
   - Existing conventions
   - Design decisions
   - Anti-patterns to avoid
3. **Follow documented patterns** - Don't reinvent solutions
4. **Update documentation** if your changes affect it

**Documentation Files to Check:**
- `docs/ARCHITECTURE.md` - System architecture
- `docs/TESTING_*.md` - Testing patterns
- `docs/API_STRUCTURE_DIAGRAM.md` - API layer design
- `docs/QUICK_REFERENCE.md` - Common patterns
- Any feature-specific docs

**Example Workflow:**
```
User asks: "Add password reset feature"
âœ… CORRECT:
1. Check docs/ for auth patterns
2. Check existing auth endpoints structure
3. Follow established patterns
4. Implement feature
5. Update docs with new endpoint

âŒ WRONG:
1. Implement immediately without checking docs
2. Use different patterns than rest of codebase
3. Don't update documentation
```

### Rule 2: Always Update Tests When Changing Code

**EVERY code change MUST include corresponding test updates:**

**When adding new functionality:**
- âœ… Write tests BEFORE or ALONGSIDE implementation (TDD)
- âœ… Cover happy path + edge cases + error cases
- âœ… Ensure minimum 80% coverage for new code

**When modifying existing code:**
- âœ… Update tests to reflect new behavior
- âœ… Add tests for new branches/conditions
- âœ… Verify all existing tests still pass
- âœ… Check coverage didn't decrease

**When refactoring:**
- âœ… Ensure tests pass before refactoring
- âœ… Keep tests passing during refactoring
- âœ… Update test structure if needed
- âœ… Verify coverage maintained or improved

**When fixing bugs:**
- âœ… Write test that reproduces the bug FIRST
- âœ… Verify test fails
- âœ… Fix bug
- âœ… Verify test now passes
- âœ… Add related edge case tests

**Types of Tests to Consider:**
1. **Unit Tests** - Test individual functions/methods in isolation
2. **Integration Tests** - Test component interactions (service + repository)
3. **API Tests** - Test HTTP endpoints end-to-end
4. **Edge Case Tests** - Test boundary conditions and error paths

**Example - Adding a New Method:**
```python
# âŒ WRONG - Just adding code without tests
class UserService:
    def deactivate_user(self, user_id: int) -> User:
        user = self.repository.get(user_id)
        user.is_active = False
        self.repository.commit()
        return user

# âœ… CORRECT - Add tests with the code
# In app/tests/services/test_user_service.py

def test_deactivate_user_with_valid_id_deactivates_user(mock_user_repository):
    # Arrange
    mock_user = create_mock_user(id=1, is_active=True)
    mock_user_repository.get.return_value = mock_user
    service = UserService(mock_user_repository)
    
    # Act
    result = service.deactivate_user(1)
    
    # Assert
    assert result.is_active is False
    mock_user_repository.commit.assert_called_once()

def test_deactivate_user_with_invalid_id_raises_not_found(mock_user_repository):
    # Arrange
    mock_user_repository.get.return_value = None
    service = UserService(mock_user_repository)
    
    # Act & Assert
    with pytest.raises(NotFoundException):
        service.deactivate_user(999)
```

**Example - Modifying Existing Code:**
```python
# Changing UserService.update_user() to add email validation

# 1. Update implementation
class UserService:
    def update_user(self, user_id: int, update_data: UserUpdate) -> User:
        # Added email uniqueness check
        if update_data.email:
            existing = self.repository.get_by_email(update_data.email)
            if existing and existing.id != user_id:
                raise ConflictException("Email already in use")
        # ... rest of code

# 2. Add new tests
def test_update_user_with_duplicate_email_raises_conflict():
    # Test the new validation
    ...

# 3. Update existing tests if behavior changed
def test_update_user_with_valid_data_succeeds():
    # Ensure existing test still works
    ...
```

**Files to Update:**
- Implementation: `app/services/user_service.py`
- Unit tests: `app/tests/services/test_user_service.py`
- Integration tests: `app/tests/integration/test_user_service_integration.py` (if applicable)
- API tests: `app/tests/api/v1/test_users.py` (if endpoint affected)

**Verification Checklist:**
- [ ] All existing tests pass
- [ ] New tests cover new functionality
- [ ] Coverage maintained or increased
- [ ] Tests follow AAA pattern (Arrange, Act, Assert)
- [ ] Tests are independent and isolated
- [ ] Both happy and sad paths tested

**Running Tests:**
```bash
# Run all tests with coverage
make test

# Or with Docker
docker-compose exec api poetry run pytest --cov=app --cov-report=term-missing -v
```

**âŒ NEVER:**
- Change code without updating tests
- Skip tests "to save time" - they save MORE time later
- Leave broken tests
- Commit code with failing tests
- Reduce test coverage

**âœ… ALWAYS:**
- Write or update tests with code changes
- Run tests before committing
- Maintain or improve coverage
- Test edge cases and error paths
- Keep tests clean and maintainable

## SOLID Principles & Code Design

Always follow **SOLID principles** for maintainable, testable code:

**S - Single Responsibility Principle:**
- Each class/function should have ONE reason to change
- Services handle business logic, repositories handle data access, controllers handle HTTP
- âœ… `UserService.create_user()` - handles user creation logic
- âŒ `UserService.create_user_and_send_email_and_log()` - too many responsibilities

**O - Open/Closed Principle:**
- Open for extension, closed for modification
- Use dependency injection to allow behavior changes without modifying code
- âœ… Inject different `PasswordService` implementations
- âŒ Modify `UserService` code for every password strategy

**L - Liskov Substitution Principle:**
- Subtypes must be substitutable for their base types
- If `UserRepository` is expected, any implementation should work
- âœ… `MockUserRepository` can replace `UserRepository` in tests
- âŒ Mock that changes behavior unexpectedly

**I - Interface Segregation Principle:**
- Don't force clients to depend on methods they don't use
- Keep interfaces/protocols focused and minimal
- âœ… `IUserReader` separate from `IUserWriter`
- âŒ Single `IUserRepository` with 50 methods

**D - Dependency Inversion Principle:**
- Depend on abstractions, not concretions
- High-level modules shouldn't depend on low-level modules
- âœ… `UserService(repository: UserRepository)` - depends on abstraction
- âŒ `UserService(db: Session)` creating its own `UserRepository` - depends on concrete implementation

## Separation of Concerns

**Layer Architecture:**
```
Controllers (HTTP Layer)
    â†“ depends on
Services (Business Logic Layer)
    â†“ depends on
Repositories (Data Access Layer)
    â†“ depends on
Models (Database Layer)
```

**What goes where:**
- **Controllers/Routers** (`app/api/`): HTTP request/response, routing, validation
- **Services** (`app/services/`): Business logic, orchestration, domain rules
- **Repositories** (`app/repositories/`): Database queries, data persistence
- **Models** (`app/models/`): Database schema, ORM models
- **DTOs** (`app/dto/`): Data transfer objects, request/response schemas
- **Middleware** (`app/middleware/`): Cross-cutting concerns (auth, logging, metrics)

**Rules:**
- Controllers NEVER access database directly - use services
- Services NEVER construct SQL - use repositories
- Repositories NEVER contain business logic - just data access
- Models are JUST data structure - no business logic

## Test-Friendly Code Structure

**Always write code with testability in mind:**

1. **Use Dependency Injection:**
```python
# âœ… Testable - can inject mocks
class UserService:
    def __init__(self, repository: UserRepository, password_service: PasswordService):
        self.repository = repository
        self.password_service = password_service

# âŒ Not testable - creates own dependencies
class UserService:
    def __init__(self, db: Session):
        self.repository = UserRepository(db)
        self.password_service = PasswordService()
```

2. **Avoid Global State:**
```python
# âœ… Good - no global state
def process_user(user: User, config: Config) -> Result:
    ...

# âŒ Bad - global state
CURRENT_USER = None  # Global variable
def process_user():
    global CURRENT_USER
    ...
```

3. **Keep Functions Pure When Possible:**
```python
# âœ… Pure function - easy to test
def calculate_discount(price: Decimal, discount_rate: Decimal) -> Decimal:
    return price * discount_rate

# âŒ Impure function - hard to test
def calculate_discount(user_id: int) -> Decimal:
    user = db.query(User).get(user_id)  # Side effect
    return user.cart_total * get_discount_rate()  # Hidden dependency
```

4. **Make Dependencies Explicit:**
```python
# âœ… Explicit dependencies
def send_welcome_email(user: User, email_service: EmailService) -> None:
    email_service.send(user.email, "Welcome!")

# âŒ Hidden dependencies
def send_welcome_email(user: User) -> None:
    smtp.send(user.email, "Welcome!")  # Where does smtp come from?
```

5. **Avoid Static Methods/Class Methods for Business Logic:**
```python
# âœ… Instance method - can mock
class UserService:
    def create_user(self, data: UserCreate) -> User:
        ...

# âŒ Static method - harder to mock
class UserService:
    @staticmethod
    def create_user(data: UserCreate) -> User:
        ...
```

Observability:
- **Tracing:** Use OpenTelemetry SDK from `shared/observability/opentelemetry_config.py`. Export with **OTLP** to Google Cloud (Cloud Trace) or collector. Prefer **BatchSpanProcessor**. :contentReference[oaicite:0]{index=0}
- **Metrics:** Expose `/metrics` using `prometheus-fastapi-instrumentator`. For Cloud Run, use **Managed Service for Prometheus** or the **Prometheus sidecar** to scrape. :contentReference[oaicite:1]{index=1}

Validation:
- Use **Pydantic v2** DTOs for request/response schemas.
- Add **custom validators** and **type-safe enums** in DTOs.

Error handling:
- Implement `shared/errors.py` with domain exceptions.
- Register a **global exception handler** in `app/bootstrap.py`.

Types & lint:
- **mypy** strict mode, **ruff** (rules + isort), **black** (88), **pyproject.toml** included.
- CI fails on lint/type errors.

Bootstrap pattern:
- Entrypoint: `app/main.py` calls **`create_app()`** from `app/bootstrap.py`.
- `create_app()` wires: routers, middlewares, CORS, OTel, metrics, error handlers, lifespan.
- Respect `AppConfig` from env/Secret Manager (see `shared/config.py`).

APIs structure:
- Controllers/routers in `app/api/*`; domain/services in `app/domain/*`.
- DTOs in `app/api/dto/*`.
- Use **tags** for Swagger grouping and `response_model` for outputs.

Queues:
- If service needs background processing, implement a **Celery** worker in `queue/worker.py` with **explicit retry/backoff** and **idempotency keys**.
- Configure Redis broker/backends via `shared/redis.py`.

Redis:
- Use `shared/redis.py` with `RedisNamespace` enum and `BaseRedisService` (async).
- Namespaces per team/domain to avoid key collisions.

Instrumentation:
- Keep OTel config in `shared/observability/`. Include FastAPI instrumentation (automatic + manual spans where useful). :contentReference[oaicite:2]{index=2}

Tests:
- **pytest** with **httpx TestClient** for API tests, factory fixtures for DB/Redis, and coverage. :contentReference[oaicite:3]{index=3}
- Unit tests next to code or under `tests/`. Providers and L2 tests must be covered.
- **Test-Driven Development (TDD):** Write tests first, then implement features
- **Coverage target:** â‰¥80% overall, â‰¥90% for services
- **See `.cursor/01-testing-rules.mdc`** for comprehensive testing best practices

Dev & Local:
- `docker-compose.yml` for Postgres + Redis + app.
- `make` targets for common tasks (`run`, `test`, `lint`, `typecheck`).

Deployment (GCP):
- **Cloud Build** â†’ build & push to **Artifact Registry** â†’ deploy to **Cloud Run**.
- `cloudbuild.yaml` and `deploy/cloudrun.yaml` provided.
- Configure OTel via env (`OTEL_EXPORTER_OTLP_ENDPOINT`, `OTEL_RESOURCE_ATTRIBUTES`, etc.). Prefer **OTLP** to Google Cloud or Collector. :contentReference[oaicite:4]{index=4}

Healthchecks:
- `/healthz` (fast), `/readyz` (DB/Redis readiness), `/metrics` (Prometheus).

Security & Config:
- No secrets in code. Pull from env or **Secret Manager** at start.
- Enforce CORS, rate limits (if needed), and request size limits.

## File and Folder Structure

For a comprehensive explanation of the project structure, see **`docs/ARCHITECTURE.md`**.

**Quick Overview:**

```
rovet-back-end/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ api/              # HTTP endpoints (controllers)
â”‚   â”‚   â”œâ”€â”€ deps.py       # Dependency injection providers
â”‚   â”‚   â””â”€â”€ v1/endpoints/ # API v1 endpoint handlers
â”‚   â”œâ”€â”€ services/         # Business logic layer
â”‚   â”œâ”€â”€ repositories/     # Data access layer
â”‚   â”œâ”€â”€ models/           # Database models (SQLAlchemy)
â”‚   â”œâ”€â”€ schemas/          # Pydantic schemas (internal)
â”‚   â”œâ”€â”€ dto/              # Data Transfer Objects (API contracts)
â”‚   â”œâ”€â”€ middleware/       # Custom middleware
â”‚   â”œâ”€â”€ core/             # Configuration & utilities
â”‚   â”œâ”€â”€ db/               # Database session & config
â”‚   â”œâ”€â”€ exceptions/       # Custom exceptions
â”‚   â””â”€â”€ tests/            # Test suite
â”œâ”€â”€ alembic/              # Database migrations
â”œâ”€â”€ docs/                 # Documentation
â”œâ”€â”€ scripts/              # Deployment scripts
â””â”€â”€ Makefile              # Development commands
```

**Layer Architecture:**
```
Controllers (app/api/)           â†’ Handle HTTP requests/responses
    â†“
Services (app/services/)         â†’ Business logic & orchestration
    â†“
Repositories (app/repositories/) â†’ Database queries
    â†“
Models (app/models/)             â†’ Database schema
```

**Rules:**
- Controllers NEVER query database directly â†’ use services
- Services NEVER write SQL â†’ use repositories
- Repositories NEVER contain business logic â†’ just data access
- Models are ONLY data structures â†’ no methods

